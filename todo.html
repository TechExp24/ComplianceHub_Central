<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nothing to do? List</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    /* Desktop: 50/50 with vertical hairline */
    .twocol{ max-width:1160px; margin:1.2rem auto; display:grid; grid-template-columns:1fr 1px 1fr; gap:1rem; align-items:stretch; }
    .vline{ width:1px; height:auto; background:#000; opacity:.6; }
    .list-col{ min-height:60vh; }
    .list-title{ font-weight:800; color:#000; text-align:center; margin:.25rem 0 .5rem 0; }
    .task{ background:#fff; border-radius:16px; padding:12px; box-shadow:0 10px 24px rgba(0,0,0,.15); margin:0 0 .75rem 0; user-select:none; cursor:pointer; }
    .task-head{ display:flex; align-items:center; justify-content:space-between; gap:.5rem; }
    .task-title{ font-weight:800; color:#000; }
    .badge{ font-size:.85rem; padding:.15rem .5rem; border-radius:999px; background:#eaeaea; color:#000; white-space:nowrap; }
    .badge.warn{ background:#ffe0e0; }
    .meta{ margin-top:.4rem; font-size:.9rem; color:#333; }
    .meta .who{ font-weight:700; }
    .meta .date{ opacity:.8; }
    .empty{ opacity:.7; background:#f5f5f5; border:1px dashed #ccc; padding:14px; border-radius:12px; text-align:center; font-weight:600; }
    /* Mobile: stack todo | line | completed */
    @media (max-width:720px){
      .twocol{ grid-template-columns:1fr; grid-template-rows:auto 1px auto; gap:.9rem; }
      .vline{ width:100%; height:1px !important; margin:.2rem 0; }
      .task{ padding:10px; }
      .task-title{ font-size:.95rem; }
    }
  </style>
</head>
<body class="form-dashboard" style="display:none">
  <div class="header2">
    <h1 class="hero-title"><strong>Nothing to do? List</strong></h1>
  </div>
  <div class="welcome-banner" style="width:100%;max-width:1160px;margin:0 auto .5rem auto;text-align:center;">
    <p style="margin:.25rem 0;font-weight:600;color:#000;">Welcome, <span id="welcome-name">User</span></p>
  </div>

  <div class="twocol">
    <div class="list-col" id="todo-col">
      <div class="list-title">To-Do</div>
      <div id="todo-list"></div>
    </div>
    <div class="vline"></div>
    <div class="list-col" id="done-col">
      <div class="list-title">Completed</div>
      <div id="done-list"></div>
    </div>
  </div>

  <div class="logout"><button id="logout-btn">Logout</button></div>

  <script>
    // ===== Session & welcome =====
    (function(){
      if (!sessionStorage.getItem('loggedIn')) { document.body.style.display='none'; window.location.href='index.html'; return; }
      document.body.style.display='block';
      const n = sessionStorage.getItem('userName') || 'User';
      const wn = document.getElementById('welcome-name'); if (wn) wn.textContent = n;
    })();

    // ===== REMOTE CONFIG: set these two =====
    const TASKS_API_URL   = "https://script.google.com/macros/s/AKfycbzs1ogWtG6BvIms9BR7-SqE4Eqg9qpBxZ1QOa4WMC3wTf7fG-DvoAH71bFsX7CPhrgv7A/exec"; // e.g. https://script.google.com/macros/s/AKfyc.../exec
    const TASKS_SECRET    = "b7f2c9d8e1a44f0f8f6c1a0b3e9d7c54";   // same as Script property WEBHOOK_SECRET

    // (optional) logging (re-use same endpoint/secret as your logger)
    const SHEETS_WEB_APP_URL = TASKS_API_URL;  // same app handles POST
    const LOG_SECRET         = TASKS_SECRET;

    // ===== Core vars =====
    const DAY_MS = 24*60*60*1000;
    const businessFile = (sessionStorage.getItem('userBusiness') || '').replace(/\.html$/,'');
    const userName     = sessionStorage.getItem('userName') || 'Unknown';

    const KEY_PREFIX = 'todo:v3'; // version bump (now remote tasks)
    const keyFor = (tid) => `${KEY_PREFIX}:${businessFile}:${tid}`;
    const CACHE_KEY = `task-cache:${businessFile}`;

    const todoList = document.getElementById('todo-list');
    const doneList = document.getElementById('done-list');

    // ===== Fetch tasks from Google Sheets =====
    async function fetchTasks(){
      const url = new URL(TASKS_API_URL);
      url.searchParams.set('business', businessFile);
      const res = await fetch(url.toString(), { headers: {'X-Webhook-Secret': TASKS_SECRET} });
      if (!res.ok) throw new Error('tasks fetch failed');
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || 'bad response');
      return data.tasks || [];
    }

    function cacheTasks(tasks){
      try { localStorage.setItem(CACHE_KEY, JSON.stringify({ts:Date.now(), tasks})); } catch(_) {}
    }
    function readCachedTasks(){
      try {
        const obj = JSON.parse(localStorage.getItem(CACHE_KEY) || '{}');
        return Array.isArray(obj.tasks) ? obj.tasks : [];
      } catch(_) { return []; }
    }

    // ===== DOM task nodes (built after we know the tasks) =====
    const nodes = {};
    let tasksForBiz = [];

    function buildNodes(){
      todoList.innerHTML = ''; doneList.innerHTML = '';
      for (const t of tasksForBiz){
        const el = document.createElement('div');
        el.className = 'task';
        el.dataset.tid = t.id;
        el.innerHTML = `
          <div class="task-head">
            <div class="task-title">${t.title}</div>
            <span class="badge"></span>
          </div>
          <div class="meta"></div>
        `;
        // click => complete
        el.addEventListener('click', () => handleComplete(t.id));
        // long-press => undo (only when completed)
        let pressTimer = null;
        el.addEventListener('pointerdown', () => {
          if (!isCompleted(t.id)) return;
          pressTimer = setTimeout(() => handleUndo(t.id), 2000);
        });
        ['pointerup','pointerleave','pointercancel'].forEach(ev =>
          el.addEventListener(ev, () => { if (pressTimer){ clearTimeout(pressTimer); pressTimer=null; }})
        );
        nodes[t.id] = el;
      }
    }

    // ===== State helpers =====
    function getTaskMeta(tid){ return tasksForBiz.find(t => t.id === tid) || {days:7, title:tid}; }
    function getPeriodMs(tid){ const d = Number(getTaskMeta(tid).days) || 7; return d * DAY_MS; }

    function getState(tid){ try { return JSON.parse(localStorage.getItem(keyFor(tid))||'null'); } catch(_) { return null; } }
    function setState(tid, st){ localStorage.setItem(keyFor(tid), JSON.stringify(st)); }
    function clearState(tid){ localStorage.removeItem(keyFor(tid)); }
    function isCompleted(tid){ return !!getState(tid)?.completedAt; }

    function msUntilReturn(tid){
      const st = getState(tid); if (!st) return null;
      return new Date(st.completedAt).getTime() + getPeriodMs(tid) - Date.now();
    }
    function daysUntilReturn(tid){ const ms = msUntilReturn(tid); return ms==null ? null : Math.ceil(ms/DAY_MS); }
    function overdueDays(tid){
      const ms = msUntilReturn(tid); if (ms==null) return 0;
      if (ms > 0) return 0;
      return Math.floor((-ms)/DAY_MS) + 1;
    }

    function placeTask(tid){
      const el = nodes[tid]; if (!el) return;
      const st = getState(tid);
      const badge = el.querySelector('.badge');
      const meta  = el.querySelector('.meta');

      if (!st) {
        badge.textContent = ''; badge.classList.remove('warn'); meta.textContent = '';
        todoList.appendChild(el);
        return;
      }

      const od = overdueDays(tid);
      if (od > 0) {
        clearState(tid);
        badge.textContent = `due ${od} day${od>1?'s':''} ago`;
        badge.classList.add('warn');
        meta.textContent = st.by ? `Last done by ${st.by} on ${new Date(st.completedAt).toLocaleDateString()}` : '';
        todoList.appendChild(el);
      } else {
        const left = daysUntilReturn(tid);
        const d = Number(getTaskMeta(tid).days) || 7;
        badge.textContent = left ? `returns in ${left} / ${d} day${d>1?'s':''}` : `returns today`;
        badge.classList.remove('warn');
        meta.innerHTML = st.by
          ? `<span class="who">✔ finished by ${st.by}</span> <span class="date">• ${new Date(st.completedAt).toLocaleDateString()}</span>`
          : '';
        doneList.appendChild(el);
      }
    }

    function handleComplete(tid){
      if (isCompleted(tid)) return;
      const state = { completedAt: new Date().toISOString(), by: userName };
      setState(tid, state);
      placeTask(tid);
      logToSheets({ action:'complete', business:businessFile, taskId:tid,
        taskTitle:getTaskMeta(tid).title, by:userName, at:state.completedAt, days:getTaskMeta(tid).days });
    }

    function handleUndo(tid){
      const prev = getState(tid);
      clearState(tid);
      placeTask(tid);
      logToSheets({ action:'undo', business:businessFile, taskId:tid,
        taskTitle:getTaskMeta(tid).title, by:userName, at:new Date().toISOString(), prevCompletedAt:prev?.completedAt || null });
    }

    function sortTodo(){
      const cards = Array.from(todoList.children);
      cards.sort((a,b)=>{
        const ta=a.dataset.tid, tb=b.dataset.tid;
        const oa = overdueDays(ta), ob = overdueDays(tb);
        if (ob !== oa) return ob - oa;
        const sa = getState(ta), sb = getState(tb);
        const ea = sa ? Date.now()-new Date(sa.completedAt).getTime() : 0;
        const eb = sb ? Date.now()-new Date(sb.completedAt).getTime() : 0;
        return eb - ea;
      });
      cards.forEach(c => todoList.appendChild(c));
    }

    async function init(){
      try {
        const tasks = await fetchTasks();
        tasksForBiz = tasks;
        cacheTasks(tasks);
      } catch {
        tasksForBiz = readCachedTasks();
      }
      if (!tasksForBiz || tasksForBiz.length === 0){
        todoList.innerHTML = `<div class="empty">No tasks configured for this business yet.</div>`;
        doneList.innerHTML = '';
        return;
      }
      // normalize numbers
      tasksForBiz = tasksForBiz.map(t => ({...t, days: Number(t.days)||7}));
      buildNodes();
      tasksForBiz.forEach(t => placeTask(t.id));
      sortTodo();
    }
    init();

    // refresh every minute (for countdowns/auto-returns)
    setInterval(()=>{ if (tasksForBiz) { tasksForBiz.forEach(t => placeTask(t.id)); sortTodo(); } }, 60*1000);

    // logging to sheet (optional)
    async function logToSheets(payload){
      if (!SHEETS_WEB_APP_URL) return;
      try {
        await fetch(SHEETS_WEB_APP_URL, {
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'X-Webhook-Secret': LOG_SECRET },
          body: JSON.stringify(payload),
          mode:'cors',
          keepalive:true
        });
      } catch(e){}
    }

    // logout
    document.getElementById('logout-btn').addEventListener('click', () => {
      sessionStorage.clear(); window.location.href = 'index.html';
    });
  </script>

  <!-- shared inactivity protections -->
  <script src="disposal.js" defer></script>
</body>
</html>
